### 进程

进程的出现是为了更好的利用CPU资源使得并发成为可能。 
假设有两个任务A和B，当A遇到IO操作，CPU默默的等待任务A读取完操作再去执行任务B，这样无疑是对CPU资源的极大的浪费。
若在任务A读取数据时，让任务B执行，当任务A读取完数据后，再**切换**到任务A执行。
既然是**切换**，就会涉及到程序运行的状态
就需要有一个东西去记录任务A和任务B分别需要什么资源，而进程的作用就是这个：**记录不同程序的运行状态**
通过进程来分配系统资源，标识任务。如何分配CPU去执行进程称之为调度，进程状态的记录，恢复，切换称之为**上下文切换**。
进程是系统资源分配的最小单位，进程占用的资源有：
* 地址空间
* 全局变量
* 文件描述符
* 各种硬件等等资源

### 线程

线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内**并发**成为可能。
但线程的缺陷是：若一个线程挂掉了，整一个进程也挂掉了，这意味着其它线程也挂掉了，进程却没有这个问题，一个进程挂掉，另外的进程还是活着。

### 协程

协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。 
当涉及到大规模的并发连接时：例如10K连接 
当连接数很多 —> 需要大量的线程来干活 —> 可能大部分的线程处于ready状态 —> 系统会不断地进行上下文切换。
既然性能瓶颈在上下文切换，那解决思路也就有了，在线程中自己实现调度，不陷入内核级别的上下文切换。

### 小结

* 进程，线程，协程不断突破，更高效的处理阻塞，不断地提高CPU的利用率。
但是并不是说，线程就一定比进程快，而协程就一定不线程要快。
具体还是要看应用场景。具体我们举下面几个例子

* 多核CPU，CPU密集型应用
此时多线程的效率是最高的，多线程可以使到全部CPU核心满载，又避免了协程间切换造成性能损失。
当CPU密集型任务时，CPU一直在利用着，切换反而会造成性能损失，即便协程上下文切换消耗最小，但也还是有消耗的。

* 多核CPU，IO密集型应用
此时采用多线程多协程效率最高，多线程可以使到全部CPU核心满载，而一个线程多协程，则更好的提高了CPU的利用率。

* 单核CPU，CPU密集型应用
单进程效率是最高，此时单个进程已经使到CPU满载了。

* 单核CPU，IO密集型应用
多协程，效率最高。




### 并行

并行就是指同一时刻有两个或两个以上的“工作单位”在同时执行，
从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。
所以：**多核是并行的前提**，单线程永远无法达到并行状态。可以利用多线程和度进程到达并行状态。
Python的多线程由于**GIL**的存在，对于Python来说无法通过多线程到达并行状态。

### 并发

并发实际上是一种设计模式，有了并发的设计，并行才得以实现
可以简单粗暴的理解为：不管你有多少个线程，只要系统能在一段时间内同时处理，就是并发的
并行与并发的关系: 并发的设计使到并发执行成为可能，而并行是并发执行的其中一种模式。

